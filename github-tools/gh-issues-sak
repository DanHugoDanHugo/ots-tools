#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# GitHub issues "Swiss Army knife": manipulate a GitHub repository's issues.
# github.com/OpenTechStrategies/ots-tools/blob/master/github-tools/gh-issues-sak
#
# Copyright (C) 2018 Open Tech Strategies, LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

__doc__ = """\
Manipulate issues associated with a GitHub repository.  Usage:

  $ ./gh-issues-sak --repository OWNER/REPOS [SUBCOMMAND | --infile INPUT_FILE]

OWNER/REPOS is something like "solutionguidance/psm".

No SUBCOMMANDs are supported right now; watch this space for more.

Specifying batch operations
---------------------------

The '--infile INPUT_FILE' option passes a JSON-format file that gives
various batch operations to perform on a per-issue basis.  

The top level structure is a list, and each element of the list is a
dictionary.  The only required entry in that dictionary is "issue",
whose value is the issue number (an integer).  The other dictionary
entries are optional and represent operations to perform on the issue:

    [
        {
            "issue":         1729,
            "add-labels":    ["REQ-1", "HARD"],
            "remove-labels": ["REQ-5", "EASY"]
	},
        ...
    ]

List elements are processed in order from top to bottom; it's okay
(though somewhat silly) for the same issue to appear multiple times.

Labels will be created as necessary, always with a black background.
Removing a label that doesn't exist is merely a no-op, not an error.

GitHub authentication and authorization
---------------------------------------

Each time you run this script, you will be prompted for a GitHub
authorization token.  If you don't have a token, or don't know what
one is, just hit Enter and you'll be pointed to further instructions.
We might later add an option to pass the auth token in via a file, but
we won't pass it via a command line option because then it could be
leaked via 'ps' listings, shell history, etc.
"""

import sys
import getopt
import getpass
import json
import github
import github.GithubException

def main():
    owner_name = None
    repos_name = None
    infile = None
    auth_token = None

    try:
        (opts, args) = getopt.getopt(
            sys.argv[1:], "h?", 
            ["help", "repository=", "infile=",])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("h", "--help",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("--repository",):
            owner_name, repos_name = optarg.split("/")
        elif opt in ("--infile",):
            if optarg == "-":
                infile = sys.stdin
            else:
                infile = open(optarg, "r")
        
    if (owner_name is None) or (repos_name is None):
        sys.stderr.write("ERROR: '--repository' option must supply "
                         "owner and repository, like this:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  owner_name/repository_name\n")
        sys.stderr.write("\n")
        sys.stderr.write("For example:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  solutionguidance/psm\n")
        sys.stderr.write("\n")
        sys.exit(1)

    if infile is None:
        sys.stderr.write("ERROR: '--infile INPUT_FILE' option is required\n")
        sys.exit(1)

    auth_token = getpass.getpass("GitHub authorization token ('?' for help): ")
    if auth_token == "?" or auth_token == "":
        print("https://help.github.com/articles/"
              "creating-a-personal-access-token-for-the-command-line")
        print("has instructions for generating a GitHub API personal"
              "access token.")
        print("")
        auth_token = getpass.getpass("GitHub authorization token: ")

    g = github.Github(auth_token)

    # We're taking advantage of some lazy polymorphism here.  Either
    # "organization/repository" or "username/repository" will work,
    # even though we only advertize the former.  So far, all of the
    # methods we're invoking exist for either type of object.  If that
    # changes, we can make a wrapper object to handle method dispatch.
    try:
        owner = g.get_organization(owner_name)
    except github.UnknownObjectException as e:
        owner = g.get_user(owner_name)

    repos = owner.get_repo(repos_name)
    commands = json.load(infile)

    for command in commands:
        issue_number = command['issue']
        labels_to_add = command.get('add-labels')
        labels_to_remove = command.get('remove-labels')
        if (labels_to_add is None) and (labels_to_remove is None):
            continue
        issue = repos.get_issue(issue_number)
        # Only set any labels if we're operating on the designated
        # test repository.  (There was an an... accident... in which
        # on 2018-02-26 I accidentally put the "REQ-1" label on every
        # issue in solutionguidance/psm.  I've since fixed that, and
        # and this conditional guards against future such missteps.)
        if owner_name.lower() == "opentechstrategies" \
           and repos_name.lower() == "test-repository": 
            if labels_to_add is not None:
                for label_name in labels_to_add:
                    try:
                        label = repos.get_label(label_name)
                    except github.GithubException as e:
                        label = repos.create_label(label_name, "000000")
                    issue.add_to_labels(label)
            labels_found = issue.labels
            if labels_to_remove is not None:
                for label_name in labels_to_remove:
                    if label_name in [x.name for x in labels_found]:
                        label = repos.get_label(label_name)
                        issue.remove_from_labels(label)
        # We have to refetch the issue to see the above changes take
        # effect in our local object, because it turns out PyGithub
        # doesn't automatically keep local objects in sync with the
        # changes made to upstream.  If we didn't re-fetch, then when
        # we print out the issue and its labels below, we'd see the
        # label set from *before* the additions/removals done above.
        issue = repos.get_issue(issue_number)
        print("%5d %s: %s" % (issue.number,
                              "{:>8}".format("(" + issue.state + ")"),
                              issue.title))
        for label in issue.labels:
            print("                - label \"%s\"" % label.name)


if __name__ == '__main__':
    main()
