#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Add labels to a GitHub repository.
# github.com/OpenTechStrategies/ots-tools/blob/master/github-tools/add-labels
#
# Copyright (C) 2018 Open Tech Strategies, LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

__doc__ = """\
WIP WARNING: This is a work in progress.  It's still just a toy.

Add labels to tickets in a GitHub repository's issue tracker.  Usage:

  $ ./add-labels --repository OWNER/REPOS --infile INPUT_FILE

OWNER/REPOS is something like "solutionguidance/psm".

INPUT_FILE is a file assigning labels to ticket numbers, whose format
is yet to be determined, because this script isn't finished yet.
(Note: we'll probably have this script auto-create labels as needed,
rather than bother the user with an explicit label-creation step.)

You'll be prompted for a GitHub authorization token; we may later add
an option to pass the auth token in via a file.  We don't pass the
auth token via a command line option because then it could be leaked
via 'ps' listings, shell history, etc.
"""

import sys
import getopt
import getpass
import github
import github.GithubException

def main():
    owner_name = None
    repos_name = None
    infile = None
    auth_token = None

    try:
        (opts, args) = getopt.getopt(
            sys.argv[1:], "h?", 
            ["help", "repository=", "infile=",])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("h", "--help",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("--repository",):
            owner_name, repos_name = optarg.split("/")
        elif opt in ("--infile",):
            if optarg == "-":
                infile = sys.stdin
            else:
                infile = open(optarg, "r")
        
    if (owner_name is None) or (repos_name is None):
        sys.stderr.write("ERROR: --repository option must supply "
                         "owner and repository, like this:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  owner_name/repository_name\n")
        sys.stderr.write("\n")
        sys.stderr.write("For example:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  solutionguidance/psm\n")
        sys.stderr.write("\n")
        sys.exit(1)

    auth_token = getpass.getpass("GitHub authorization token ('?' for help): ")
    if auth_token == "?":
        print("https://help.github.com/articles/"
              "creating-a-personal-access-token-for-the-command-line")
        print("has instructions for generating a GitHub API personal"
              "access token.")
        print("")
        auth_token = getpass.getpass("GitHub authorization token: ")

    g = github.Github(auth_token)

    # We're taking advantage of some lazy polymorphism here.  Either
    # "organization/repository" or "username/repository" will work,
    # even though we only advertize the former.  So far, all of the
    # methods we're invoking exist for either type of object.  If that
    # changes, we can make a wrapper object to handle method dispatch.
    try:
        owner = g.get_organization(owner_name)
    except github.UnknownObjectException as e:
        owner = g.get_user(owner_name)

    repos = owner.get_repo(repos_name)
    issues = repos.get_issues(state="all")

    # "Is this thing on?"  For now, print all the issues and add the
    # black "REQ-1" label to them (creating the label if necessary).
    for issue in issues:
        print("%5d %s: %s" % (issue.number,
                              "{:>8}".format("(" + issue.state + ")"),
                              issue.title))
        # Only set any labels if we're operating on the designated
        # test repository.  (There was an an... accident... in which
        # on 2018-02-26 I accidentally put the "REQ-1" label on every
        # issue in solutionguidance/psm.  I've since fixed that, and
        # and this conditional guards against future such missteps.)
        if owner_name.lower() == "opentechstrategies" \
           and repos_name.lower() == "test-repository": 
            try:
                label = repos.get_label("REQ-1")
            except github.GithubException as e:
                label = repos.create_label("REQ-1", "000000")
            issue.add_to_labels(label)
        # I think it's a bug in PyGithub that even if we added the
        # label to the issue above, the new label won't be included in
        # issue.labels below -- even though the label *is* associated
        # with the issue on GitHub now, and on the next run of this
        # script you will see the label on the issue.  The local
        # object should be kept in sync with upstream, but apparently
        # that's not happening.
        for label in issue.labels:
            print("                - label \"%s\"" % label.name)


if __name__ == '__main__':
    main()
