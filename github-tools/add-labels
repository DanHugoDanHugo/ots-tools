#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Add labels to a GitHub repository.
# github.com/OpenTechStrategies/ots-tools/blob/master/github-tools/add-labels
#
# Copyright (C) 2018 Open Tech Strategies, LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

__doc__ = """\
Add and remove labels in a GitHub repository's issue tracker.  Usage:

  $ ./add-labels --repository OWNER/REPOS --infile INPUT_FILE

OWNER/REPOS is something like "solutionguidance/psm".

INPUT_FILE is a file adding/removing labels to/from issue tickets.
The format of the file is self-explanatory JSON:

    [
        {
            "issue":         1729,
            "add-labels":    ["REQ-1", "HARD"],
            "remove-labels": ["REQ-5", "EASY"]
	},
        ...
    ]

The "issue" field is required, but the other two fields are optional.
The entries will be processed in order from top to bottom; it's okay
(though somewhat silly) for the same issue to appear multiple times.
Labels will be created as necessary, always with a black background.
Removing a label that doesn't exist is merely a no-op, not an error.

Each time you run this script, you will be prompted for a GitHub
authorization token.  If you don't have a token, or don't know what
one is, just hit Enter and you'll be pointed to further instructions.
We might later add an option to pass the auth token in via a file, but
we won't pass it via a command line option because then it could be
leaked via 'ps' listings, shell history, etc.
"""

import sys
import getopt
import getpass
import json
import github
import github.GithubException

def main():
    owner_name = None
    repos_name = None
    infile = None
    auth_token = None

    try:
        (opts, args) = getopt.getopt(
            sys.argv[1:], "h?", 
            ["help", "repository=", "infile=",])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("h", "--help",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("--repository",):
            owner_name, repos_name = optarg.split("/")
        elif opt in ("--infile",):
            if optarg == "-":
                infile = sys.stdin
            else:
                infile = open(optarg, "r")
        
    if (owner_name is None) or (repos_name is None):
        sys.stderr.write("ERROR: '--repository' option must supply "
                         "owner and repository, like this:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  owner_name/repository_name\n")
        sys.stderr.write("\n")
        sys.stderr.write("For example:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  solutionguidance/psm\n")
        sys.stderr.write("\n")
        sys.exit(1)

    if infile is None:
        sys.stderr.write("ERROR: '--infile INPUT_FILE' option is required\n")
        sys.exit(1)

    auth_token = getpass.getpass("GitHub authorization token ('?' for help): ")
    if auth_token == "?" or auth_token == "":
        print("https://help.github.com/articles/"
              "creating-a-personal-access-token-for-the-command-line")
        print("has instructions for generating a GitHub API personal"
              "access token.")
        print("")
        auth_token = getpass.getpass("GitHub authorization token: ")

    g = github.Github(auth_token)

    # We're taking advantage of some lazy polymorphism here.  Either
    # "organization/repository" or "username/repository" will work,
    # even though we only advertize the former.  So far, all of the
    # methods we're invoking exist for either type of object.  If that
    # changes, we can make a wrapper object to handle method dispatch.
    try:
        owner = g.get_organization(owner_name)
    except github.UnknownObjectException as e:
        owner = g.get_user(owner_name)

    repos = owner.get_repo(repos_name)
    commands = json.load(infile)

    for command in commands:
        issue_number = command['issue']
        labels_to_add = command.get('add-labels')
        labels_to_remove = command.get('remove-labels')
        if (labels_to_add is None) and (labels_to_remove is None):
            continue
        issue = repos.get_issue(issue_number)
        # Only set any labels if we're operating on the designated
        # test repository.  (There was an an... accident... in which
        # on 2018-02-26 I accidentally put the "REQ-1" label on every
        # issue in solutionguidance/psm.  I've since fixed that, and
        # and this conditional guards against future such missteps.)
        if owner_name.lower() == "opentechstrategies" \
           and repos_name.lower() == "test-repository": 
            if labels_to_add is not None:
                for label_name in labels_to_add:
                    try:
                        label = repos.get_label(label_name)
                    except github.GithubException as e:
                        label = repos.create_label(label_name, "000000")
                    issue.add_to_labels(label)
            labels_found = issue.labels
            if labels_to_remove is not None:
                for label_name in labels_to_remove:
                    if label_name in [x.name for x in labels_found]:
                        label = repos.get_label(label_name)
                        issue.remove_from_labels(label)
        # We have to refetch the issue to see the above changes take
        # effect in our local object, because it turns out PyGithub
        # doesn't automatically keep local objects in sync with the
        # changes made to upstream.  If we didn't re-fetch, then when
        # we print out the issue and its labels below, we'd see the
        # label set from *before* the additions/removals done above.
        issue = repos.get_issue(issue_number)
        print("%5d %s: %s" % (issue.number,
                              "{:>8}".format("(" + issue.state + ")"),
                              issue.title))
        for label in issue.labels:
            print("                - label \"%s\"" % label.name)


if __name__ == '__main__':
    main()
