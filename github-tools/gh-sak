#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# gh-sak: A GitHub "Swiss Army knife" for doing batch manipulation of
#         things (issues, labels, etc) in a GitHub repository.
# 
# github.com/OpenTechStrategies/ots-tools/blob/master/github-tools/gh-sak
#
# Copyright (C) 2018 Open Tech Strategies, LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

__doc__ = """\
Manipulate issues associated with a GitHub repository.  Usage:

  $ ./gh-sak [--root OWNER[/REPOS]] [ --infile INPUT_FILE ] COMMAND

OWNER/REPOS is something like "opentechstrategies/ots-tools".

Some COMMANDs, e.g., listing all issues, require no further specification.
Others COMMANDs, such as determining different labels across a bunch
of issues, operate batch-style on an input set passed via INPUT_FILE.
INPUT_FILE is a JSON-format file whose structure depends on COMMAND.

GitHub authentication and authorization
---------------------------------------

Each time you run this script, you will be prompted for a GitHub
authorization token.  If you don't want to be prompted, put the token
as the first line of a file (you might want to restrict that file's
permissions so that only you can read it) and pass the file with the
'--auth-token-file' option, like so:

  $ ./gh-sak --auth-token-file FILE_CONTAINING_TOKEN ...

(We don't offer a way to pass the token directly via the command line
because then it could be leaked via 'ps' listings, shell history, etc.)

Available COMMANDs
------------------

* "list-repositories"  (no input file)

   List all the repositories under OWNER (i.e., use with '--root OWNER').

   This is the only command for which the /REPOSITORY component of the
   parameter to the --root option is not required (indeed, must be
   left off).

* "tickets-summary-org"  (no input file)

  This lists all issues and pull requests, both open and closed/merged,
  in an Emacs Org Mode format, like so:

    * [[https://github.com/blah/blah/issues/1][1]]   (open): issue title
  
      body (i.e., first comment) here
  
    ** 3 comments
    ** 2 labels
       - some label name
       - another label name

    * [[https://github.com/blah/blah/issues/2][2]] (closed): other title
  
      other body (i.e., first comment) here
  
    ** 0 comments
    ** 0 labels

    * [[https://github.com/blah/blah/pull/3][3]] (merged): another title
  
      another body (i.e., first comment) here
 
    ** 2 comments
    ** 8 reviews
    ** 1 labels
       - yet another label name

* "list-labels"  (no input file)

  Print a list of all labels in the repository, one per line.

* "edit-issues"  (input file required)

  Manipulate issues in various ways.  Right now, the only manipulation
  supported is adding/removing existing labels to/from issues.  (See
  also the "edit-labels" command.)

  The top level structure of the JSON is a list.  Each element of that
  list is a dictionary.  The only required entry in each dictionary is
  "issue", whose value is an issue number (an integer), and each
  remaining entry is an action to take regarding that issue.  The two
  actions implemented so far are "add-labels" and "remove-labels",
  and the value in both cases is a list of label names (strings).
  For example:

    [
        {
            "issue":         1729,
            "add-labels":    ["REQ-1", "HARD"],
            "remove-labels": ["REQ-5", "EASY"]
	},
        ...
    ]

  Labels will be created as necessary, always with a gray background,
  but if a label already exists its current color will not be changed.

  Removing a label that doesn't exist is merely a no-op, not an error.

  List elements are processed in order from top to bottom; it's fine,
  though somewhat silly, for the same issue to appear multiple times.

* "edit-labels"  (input file required)

  Create, delete, rename, and change colors of labels.

  The JSON is a list of sublists:

    [ [ OLD_LABEL_NAME, NEW_LABEL_NAME, COLOR ] ...]

  Each sublist can be used to create a new label, delete an existing
  label, rename a label, change the color of a label, or rename and
  change color simultaneously.  This logic chart explains how:

    OLD_LABEL_NAME null:
      NEW_LABEL_NAME null:
        COLOR null:     ==>  ERROR
        COLOR "color":  ==>  ERROR
      NEW_LABEL_NAME "new_name":
        COLOR null:     ==>  create new label with default gray ("e2e2e2")
        COLOR "color":  ==>  create new label with color "color"
    OLD_LABEL_NAME "old_name"
      NEW_LABEL_NAME null:
        COLOR null:     ==>  delete old label
        COLOR "color":  ==>  give old label new color "color"
      NEW_LABEL_NAME "new_name":
        COLOR null:     ==>  rename label but preserve old color
        COLOR "color":  ==>  rename label and give it new color "color"

  The top-level list is processed in order, and each element takes
  effect as soon as it is processed.

* rate-limit-info (no input file)

  Just print information about your current GitHub rate limit status.

Notes
-----

This code is not librarized yet.  To be a library, it would need at
least these changes:

   - All the errors followed by sys.exit(1) would need to become
     exceptions raised.

   - The inline print statements would need to be omitted or become
     some kind of progress callback.
"""

import sys
import time
import getopt
import getpass
import json
import requests

def get_input(infile):
    """Return the data structure represented by the JSON in INFILE.
    If INFILE is None, exit with usage recommendation and error."""
    if infile is None:
        sys.stderr.write("ERROR: "
                         "'--input-file INPUT_FILE' required\n"
                         "       (run with --help to see usage)\n")
        sys.exit(1)
    return json.load(infile)


def do_query(query, headers):
    """Send QUERY to GitHub (v4 GraphQL API) and return the response."""
    request = requests.post('https://api.github.com/graphql', 
                            json={'query': query}, 
                            headers=headers)
    if request.status_code == 200:
        return request.json()
    else:
        raise Exception("ERROR: error {} returned for query \"{}\".".format(
            request.status_code, query))


def main():
    command = None
    owner_name = None
    repos_name = None
    infile = None
    auth_token = None

    try:
        (opts, args) = getopt.getopt(
            sys.argv[1:], "h?", 
            ["help", "usage", "auth-token-file=", "root=", "infile=",])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("-h", "-?", "--help", "--usage",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("--auth-token-file",):
            with open(optarg, "r") as f:
                auth_token = f.readline().rstrip()
        elif opt in ("--root",):
            # '--repository' for backwards compatibility only
            try:
                owner_name, repos_name = optarg.split("/")
            except ValueError:
                owner_name = optarg
            if owner_name == "":
                owner_name = None
            if repos_name == "":
                repos_name == None
        elif opt in ("--infile",):
            if optarg == "-":
                infile = sys.stdin
            else:
                infile = open(optarg, "r")
        
    if len(args) == 1:
        command = args[0]
    elif len(args) < 1:
        sys.stderr.write("ERROR: "
                         "command required (run with --help to see usage)\n")
        sys.exit(1)
    else:
        sys.stderr.write("ERROR: "
                         "too many commands (run with --help to see usage)\n")
        sys.exit(1)

    if ((command != "rate-limit-info")
        and ((owner_name is None)
             or ((command != "list-repositories") and (repos_name is None)))):
        sys.stderr.write("ERROR: '--root' option must supply "
                         "owner and (usually) repository, like this:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  owner_name/repository_name\n")
        sys.stderr.write("\n")
        sys.stderr.write("For example:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  solutionguidance/psm\n")
        sys.stderr.write("\n")
        sys.stderr.write("(The repository_name may be omitted for "
                         "the \"list-repositories\" command.)\n")
        sys.stderr.write("\n")
        sys.exit(1)

    if auth_token is None:
        auth_token = getpass.getpass("GitHub authorization token ('?' for help): ")
    if auth_token == "?" or auth_token == "":
        print("https://help.github.com/articles/"
              "creating-a-personal-access-token-for-the-command-line")
        print("has instructions for generating a GitHub API personal"
              "access token.")
        print("")
        auth_token = getpass.getpass("GitHub authorization token: ")

    headers = {"Authorization": "Bearer {}".format(auth_token)}

    if command == "tickets-summary-org":
        # Double braces because we're going to call .format() on this.
        query_template = """
        query
        {{
          repository(owner: "{}", name: "{}") {{
            {}(first: {}{}) {{
              totalCount
              edges {{
                node {{
                  number
                  title
                  createdAt
                  state
                  body
                  comments(first: {}) {{
                    totalCount
                  }}
                  {}
                  labels(first: {}) {{
                    totalCount
                    edges {{
                      node {{ 
                        name
                        description
                      }}
                      cursor
                    }}
                  }}
                }}
                cursor
              }}
            }}
          }}
        }}
        """
    
        requested_page_size = 100
    
        # We treat issues and pull requests mostly like they're the same
        # thing because that's how GitHub treats them.
        for ticket_type in ("issues", "pullRequests",):
            after_cursor_str = ""  # could be ", after: \"some_cursor\""
            total_count = None
            total_remaining = sys.maxsize
            while total_remaining > 0:
                reviews_str = ""
                if ticket_type == "pullRequests":
                    reviews_str = "reviews(first: {}) {{ totalCount }}"\
                        .format(requested_page_size)
    
                this_query = query_template.format(
                    owner_name, repos_name, ticket_type, 
                    requested_page_size, after_cursor_str, 
                    requested_page_size, reviews_str, requested_page_size)
    
                # TODO: Dancing the nested-after dance for interior lists,
                #       such as comments, reviews, labels, etc, is hard.
                #       Is there a good abstraction for this?  Hmmmmm.
    
                result = do_query(this_query, headers)
        
                ticket_edges = \
                    result["data"]["repository"][ticket_type]["edges"]

                # We might have gotten no results.  If so, stop here.
                if len(ticket_edges) == 0:
                    break

                last_issue_cursor = ticket_edges[-1]["cursor"]
                total_fetched = len(ticket_edges)
        
                for ticket in [te["node"] for te in ticket_edges]:
                    number  = ticket["number"]
                    state   = ticket["state"].lower()
                    title   = ticket["title"]
    
                    ticket_url_category = ticket_type
                    if ticket_type == "pullRequests":
                        ticket_url_category = "pull"  # Thanks, GitHub.
                    print("* [[https://github.com/{}/{}/{}/{}][{}]] {}: {}"
                          .format(owner_name, repos_name, ticket_url_category,
                                  number, number, 
                                  "{:>8}".format("(" + state + ")"), 
                                  title))
    
                    # The first comment is actually called the 'body', in
                    # the API.  Yes, even though the header of that
                    # comment looks exactly like the header of every other
                    # subsequent comment, and even though the header of
                    # that first comment even *says* "kfogel commented a
                    # day ago", nooooo, it's not a comment, it's a body.
                    # Every body wants to be some body, I guess.
                    body = ticket["body"]
                    if (body is None) or body == "":
                        body = "<<< THIS TICKET HAS NO BODY >>>"
                    # TextWrapper appears to be buggy; at least, this
                    # wrapper doesn't have the effects I'd expect it
                    # to on an issue body.  Leaving this here for now,
                    # but not using it.
                    # 
                    # import textwrap
                    # wrapper = textwrap.TextWrapper(initial_indent='  ',
                    #                                subsequent_indent='  ',
                    #                                replace_whitespace=False,
                    #                                drop_whitespace=False,
                    #                                break_long_words=False,
                    #                                break_on_hyphens=False)
                    # print("%s" % wrapper.fill(ticket.body))
                    print("")
                    print("{}".
                          format("\n  ".join(("\n" + body).splitlines())[1:]))
                    print("")
    
                    print("** Created: {}".format(ticket["createdAt"][0:10]))

                    # Handle comments (and reviews, if this is a PR).
                    comments_kinds = ["comments", "reviews",]
                    if ticket_type != "pullRequests":
                        comments_kinds.remove("reviews")
                    for comments_kind in comments_kinds:
                        comments_count = ticket[comments_kind]["totalCount"]
                        # We don't want to do the pluralization check here.
                        # Humans like "1 comment" vs "2 comments", but the
                        # real audience here is machines, not humans.
                        print("** {} {}".format(comments_count, comments_kind))
    
                    # Handle labels.
                    labels_count = ticket["labels"]["totalCount"]
                    label_edges = ticket["labels"]["edges"]
                    print ("** {} labels".format(labels_count))
                    for label in [le["node"] for le in label_edges]:
                        print("   - {}".format(label["name"]))
    
                # Everything from here down is cursor bookkeeping for pagination.
                # 
                # https://graphql.org/learn/pagination/ is a great resource on
                # pagination models.  GitHub uses the cursor model. 
                #
                # Some other good pages:
                # 
                # https://developer.github.com/v4/
                # https://developer.github.com/v4/explorer/
                # https://developer.github.com/v4/guides/forming-calls/
                #     (especially #example-query on the above page)
                # https://developer.github.com/v4/object/repository/
                # https://developer.github.com/v4/guides/intro-to-graphql/
                # https://developer.github.com/v4/guides/migrating-from-rest/
    
                if total_count is None:
                    # This total will never change after being set.
                    total_count = \
                        result["data"]["repository"][ticket_type]["totalCount"]
                    total_remaining = total_count - total_fetched
                else:
                    total_remaining = total_remaining - total_fetched
        
                if total_remaining > 0:
                    after_cursor_str = ", after: \"{}\""\
                        .format(last_issue_cursor)
        
                # sys.stderr.write("DEBUG: \n")
                # sys.stderr.write("{}\n".format(
                #     json.dumps(result, indent=4, sort_keys=True)))
                # sys.stderr.write(
                #     "DEBUG: {} {} fetched; {} remaining (of {})\n"
                #     .format(total_fetched, ticket_type, 
                #             total_remaining, total_count))
    elif command == "rate-limit-info":
        query = """
        {
          viewer {
            login
          }
          rateLimit {
            limit
            cost
            remaining
            resetAt
          }
        }
        """
        result = do_query(query, headers)
        limit = result["data"]["rateLimit"]["limit"]
        cost = result["data"]["rateLimit"]["cost"]
        remaining = result["data"]["rateLimit"]["remaining"]
        reset_at = result["data"]["rateLimit"]["resetAt"]
        print("GitHub rate limit info:")
        print("  - limit:     {}".format(limit))
        print("  - cost:      {}".format(limit))
        print("  - remaining: {}".format(limit))
        print("  - reset at:  {}".format(limit))
    else:
        sys.stderr.write("ERROR: Most subcommands aren't implemented yet;\n")
        sys.stderr.write("       please check back later.\n")
        

if __name__ == '__main__':
    main()
